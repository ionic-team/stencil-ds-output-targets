/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
import { Components, JSX } from 'component-library';


interface MyButtonProps {
  
  /** The color to use from your application's color palette.
Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`.
For more information on colors, see [theming](/docs/theming/basics). */
  color?: Components.MyButton["color"]
  
  /** The type of button. */
  buttonType?: Components.MyButton["buttonType"]
  
  /** If `true`, the user cannot interact with the button. */
  disabled?: Components.MyButton["disabled"]
  
  /** Set to `"block"` for a full-width button or to `"full"` for a full-width button
without left and right borders. */
  expand?: Components.MyButton["expand"]
  
  /** Set to `"clear"` for a transparent button, to `"outline"` for a transparent
button with a border, or to `"solid"`. The default style is `"solid"` except inside of
a toolbar, where the default is `"clear"`. */
  fill?: Components.MyButton["fill"]
  
  /** This attribute instructs browsers to download a URL instead of navigating to
it, so the user will be prompted to save it as a local file. If the attribute
has a value, it is used as the pre-filled file name in the Save prompt
(the user can still change the file name if they want). */
  download?: Components.MyButton["download"]
  
  /** Contains a URL or a URL fragment that the hyperlink points to.
If this property is set, an anchor tag will be rendered. */
  href?: Components.MyButton["href"]
  
  /** Specifies the relationship of the target object to the link object.
The value is a space-separated list of [link types](https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types). */
  rel?: Components.MyButton["rel"]
  
  /** The button shape. */
  shape?: Components.MyButton["shape"]
  
  /** The button size. */
  size?: Components.MyButton["size"]
  
  /** If `true`, activates a button with a heavier font weight. */
  strong?: Components.MyButton["strong"]
  
  /** Specifies where to display the linked URL.
Only applies when an `href` is provided.
Special keywords: `"_blank"`, `"_self"`, `"_parent"`, `"_top"`. */
  target?: Components.MyButton["target"]
  
  /** The type of the button. */
  type?: Components.MyButton["type"]
}

interface MyButtonEvents {
  
  /** Emitted when the button has focus. */
  myFocus: Parameters<JSX.MyButton["onMyFocus"]>[0]
  
  /** Emitted when the button loses focus. */
  myBlur: Parameters<JSX.MyButton["onMyBlur"]>[0]
}

interface MyButtonSlots {
  default: any
}
  
/* generated by Svelte v3.24.1 */
import {
	SvelteComponent,
	binding_callbacks,
	create_slot,
	detach,
	element,
	flush,
	init,
	insert,
	listen,
	run_all,
	safe_not_equal,
	set_custom_element_data,
	transition_in,
	transition_out,
	update_slot
} from "svelte/internal";

import { createEventDispatcher, onMount } from "svelte";

function create_fragment(ctx) {
	let my_button;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	return {
		c() {
			my_button = element("my-button");
			if (default_slot) default_slot.c();
			set_custom_element_data(my_button, "color", /*color*/ ctx[0]);
			set_custom_element_data(my_button, "button-type", /*buttonType*/ ctx[1]);
			set_custom_element_data(my_button, "disabled", /*disabled*/ ctx[2]);
			set_custom_element_data(my_button, "expand", /*expand*/ ctx[3]);
			set_custom_element_data(my_button, "fill", /*fill*/ ctx[4]);
			set_custom_element_data(my_button, "download", /*download*/ ctx[5]);
			set_custom_element_data(my_button, "href", /*href*/ ctx[6]);
			set_custom_element_data(my_button, "rel", /*rel*/ ctx[7]);
			set_custom_element_data(my_button, "shape", /*shape*/ ctx[8]);
			set_custom_element_data(my_button, "size", /*size*/ ctx[9]);
			set_custom_element_data(my_button, "strong", /*strong*/ ctx[10]);
			set_custom_element_data(my_button, "target", /*target*/ ctx[11]);
			set_custom_element_data(my_button, "type", /*type*/ ctx[12]);
		},
		m(target, anchor) {
			insert(target, my_button, anchor);

			if (default_slot) {
				default_slot.m(my_button, null);
			}

			/*my_button_binding*/ ctx[18](my_button);
			current = true;

			if (!mounted) {
				dispose = [
					listen(my_button, "myFocus", /*onEvent*/ ctx[14]),
					listen(my_button, "myBlur", /*onEvent*/ ctx[14])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}

			if (!current || dirty & /*color*/ 1) {
				set_custom_element_data(my_button, "color", /*color*/ ctx[0]);
			}

			if (!current || dirty & /*buttonType*/ 2) {
				set_custom_element_data(my_button, "button-type", /*buttonType*/ ctx[1]);
			}

			if (!current || dirty & /*disabled*/ 4) {
				set_custom_element_data(my_button, "disabled", /*disabled*/ ctx[2]);
			}

			if (!current || dirty & /*expand*/ 8) {
				set_custom_element_data(my_button, "expand", /*expand*/ ctx[3]);
			}

			if (!current || dirty & /*fill*/ 16) {
				set_custom_element_data(my_button, "fill", /*fill*/ ctx[4]);
			}

			if (!current || dirty & /*download*/ 32) {
				set_custom_element_data(my_button, "download", /*download*/ ctx[5]);
			}

			if (!current || dirty & /*href*/ 64) {
				set_custom_element_data(my_button, "href", /*href*/ ctx[6]);
			}

			if (!current || dirty & /*rel*/ 128) {
				set_custom_element_data(my_button, "rel", /*rel*/ ctx[7]);
			}

			if (!current || dirty & /*shape*/ 256) {
				set_custom_element_data(my_button, "shape", /*shape*/ ctx[8]);
			}

			if (!current || dirty & /*size*/ 512) {
				set_custom_element_data(my_button, "size", /*size*/ ctx[9]);
			}

			if (!current || dirty & /*strong*/ 1024) {
				set_custom_element_data(my_button, "strong", /*strong*/ ctx[10]);
			}

			if (!current || dirty & /*target*/ 2048) {
				set_custom_element_data(my_button, "target", /*target*/ ctx[11]);
			}

			if (!current || dirty & /*type*/ 4096) {
				set_custom_element_data(my_button, "type", /*type*/ ctx[12]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(my_button);
			if (default_slot) default_slot.d(detaching);
			/*my_button_binding*/ ctx[18](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let __ref;
	let __mounted = false;
	const dispatch = createEventDispatcher();
	let { color = undefined } = $$props;
	let { buttonType = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { expand = undefined } = $$props;
	let { fill = undefined } = $$props;
	let { download = undefined } = $$props;
	let { href = undefined } = $$props;
	let { rel = undefined } = $$props;
	let { shape = undefined } = $$props;
	let { size = undefined } = $$props;
	let { strong = undefined } = $$props;
	let { target = undefined } = $$props;
	let { type = undefined } = $$props;
	const getWebComponent = () => __ref;

	onMount(() => {
		__mounted = true;
	});

	const setProp = (prop, value) => {
		if (__ref) $$invalidate(13, __ref[prop] = value, __ref);
	};

	const onEvent = e => {
		e.stopPropagation();
		dispatch(e.type, e.detail);
	};

	let { $$slots = {}, $$scope } = $$props;

	function my_button_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			__ref = $$value;
			$$invalidate(13, __ref);
		});
	}

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("buttonType" in $$props) $$invalidate(1, buttonType = $$props.buttonType);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ("expand" in $$props) $$invalidate(3, expand = $$props.expand);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("download" in $$props) $$invalidate(5, download = $$props.download);
		if ("href" in $$props) $$invalidate(6, href = $$props.href);
		if ("rel" in $$props) $$invalidate(7, rel = $$props.rel);
		if ("shape" in $$props) $$invalidate(8, shape = $$props.shape);
		if ("size" in $$props) $$invalidate(9, size = $$props.size);
		if ("strong" in $$props) $$invalidate(10, strong = $$props.strong);
		if ("target" in $$props) $$invalidate(11, target = $$props.target);
		if ("type" in $$props) $$invalidate(12, type = $$props.type);
		if ("$$scope" in $$props) $$invalidate(16, $$scope = $$props.$$scope);
	};

	return [
		color,
		buttonType,
		disabled,
		expand,
		fill,
		download,
		href,
		rel,
		shape,
		size,
		strong,
		target,
		type,
		__ref,
		onEvent,
		getWebComponent,
		$$scope,
		$$slots,
		my_button_binding
	];
}

class MyButton extends SvelteComponent {
  $$prop_def: MyButtonProps;
  $$events_def: MyButtonEvents;
  $$slot_def: MyButtonSlots;

  $on<K extends keyof MyButtonEvents>(type: K, callback: (e: MyButtonEvents[K]) => any): () => void {
	  return super.$on(type, callback);
	}

  $set($$props: Partial<MyButtonProps>): void {
	  super.$set($$props);
	}

	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			color: 0,
			buttonType: 1,
			disabled: 2,
			expand: 3,
			fill: 4,
			download: 5,
			href: 6,
			rel: 7,
			shape: 8,
			size: 9,
			strong: 10,
			target: 11,
			type: 12,
			getWebComponent: 15
		});
	}

	get color() {
		return this.$$.ctx[0];
	}

	set color(color) {
		this.$set({ color });
		flush();
	}

	get buttonType() {
		return this.$$.ctx[1];
	}

	set buttonType(buttonType) {
		this.$set({ buttonType });
		flush();
	}

	get disabled() {
		return this.$$.ctx[2];
	}

	set disabled(disabled) {
		this.$set({ disabled });
		flush();
	}

	get expand() {
		return this.$$.ctx[3];
	}

	set expand(expand) {
		this.$set({ expand });
		flush();
	}

	get fill() {
		return this.$$.ctx[4];
	}

	set fill(fill) {
		this.$set({ fill });
		flush();
	}

	get download() {
		return this.$$.ctx[5];
	}

	set download(download) {
		this.$set({ download });
		flush();
	}

	get href() {
		return this.$$.ctx[6];
	}

	set href(href) {
		this.$set({ href });
		flush();
	}

	get rel() {
		return this.$$.ctx[7];
	}

	set rel(rel) {
		this.$set({ rel });
		flush();
	}

	get shape() {
		return this.$$.ctx[8];
	}

	set shape(shape) {
		this.$set({ shape });
		flush();
	}

	get size() {
		return this.$$.ctx[9];
	}

	set size(size) {
		this.$set({ size });
		flush();
	}

	get strong() {
		return this.$$.ctx[10];
	}

	set strong(strong) {
		this.$set({ strong });
		flush();
	}

	get target() {
		return this.$$.ctx[11];
	}

	set target(target) {
		this.$set({ target });
		flush();
	}

	get type() {
		return this.$$.ctx[12];
	}

	set type(type) {
		this.$set({ type });
		flush();
	}

	get getWebComponent(): HTMLMyButtonElement | undefined {
		return this.$$.ctx[15];
	}
}

export default MyButton;